<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[生成两个不同颜色的三角形（通过片段着色器）]]></title>
    <url>%2F2018%2F05%2F06%2Fopengl-base5%2F</url>
    <content type="text"><![CDATA[片段着色器FragmentShader.h 1234567891011121314#ifndef _FRAGMENTSHADER_H_#define _FRAGMENTSHADER_H_const char * fragmentShaderSource ="#version 330 core\n""out vec4 FragColor;\n""void main()&#123;\n""FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n""&#125;\0";const char* fragmentShaderSource1 ="#version 330 core\n""out vec4 FragColor;\n""void main()&#123;\n""FragColor = vec4(1.0f, 1.0f, 0.0f, 1.0f);\n""&#125;\0"; 顶点着色器VertexShader.h 1234567891011#ifndef _VERTEXSHADER_H_#define _VERTEXSHADER_H_const char* vertexShaderSource ="#version 330 core\n""layout (location = 0) in vec3 aPos;\n""void main()&#123;\n""gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n""&#125;\0";#endif // !_VERTEXSHADER_H_ main函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;glad\glad.h&gt;#include &lt;GLFW\glfw3.h&gt;#include &lt;iostream&gt;#include "VertexShader.h"#include "FragmentShader.h"void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow* window);const unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;int main() &#123; glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "LearnOpenGL", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; "Failed to create GLFW window" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl; return -1; &#125; int vertexShader = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL); glCompileShader(vertexShader); int success; char infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILEATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; int fragmentShader1 = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader1, 1, &amp;fragmentShaderSource, NULL); glCompileShader(fragmentShader1); glGetShaderiv(fragmentShader1, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(fragmentShader1, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; int fragmentShader2 = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader2, 1, &amp;fragmentShaderSource1, NULL); glCompileShader(fragmentShader2); glGetShaderiv(fragmentShader2, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(fragmentShader2, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::FRAGMENT::COMPILEATION_FAILED1\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; //因为使用了两个不同的片段着色器，所以需要创建两个着色器程序，分别链接不同的着色器 int shaderProgram1 = glCreateProgram(); glAttachShader(shaderProgram1, vertexShader); glAttachShader(shaderProgram1, fragmentShader1); glLinkProgram(shaderProgram1); glGetProgramiv(shaderProgram1, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(shaderProgram1, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::PORGRAM::LINKING_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; int shaderProgram2 = glCreateProgram(); glAttachShader(shaderProgram2, vertexShader); glAttachShader(shaderProgram2, fragmentShader2); glLinkProgram(shaderProgram2); glGetProgramiv(shaderProgram2, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(shaderProgram2, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::PORGRAM::LINKING_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; glDeleteShader(vertexShader); glDeleteShader(fragmentShader1); float firstTriangle[] = &#123; -0.9f, -0.5f, 0.0f, -0.0f, -0.5f, 0.0f, -0.45f, 0.5f, 0.0f, &#125;; float secondTriangle[] = &#123; 0.0f, -0.5f, 0.0f, 0.9f, -0.5f, 0.0f, 0.45f, 0.5f, 0.0f &#125;; unsigned int VBOs[2], VAOs[2]; glGenVertexArrays(2, VAOs); glGenBuffers(2, VBOs); //没有解除绑定的操作，因为使用了不同的VAO，所以不需要 glBindVertexArray(VAOs[0]); glBindBuffer(GL_ARRAY_BUFFER, VBOs[0]); glBufferData(GL_ARRAY_BUFFER, sizeof(firstTriangle), firstTriangle, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glBindVertexArray(VAOs[1]); glBindBuffer(GL_ARRAY_BUFFER, VBOs[1]); glBufferData(GL_ARRAY_BUFFER, sizeof(secondTriangle), secondTriangle, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); while (!glfwWindowShouldClose(window)) &#123; processInput(window); glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(shaderProgram1); glBindVertexArray(VAOs[0]); glDrawArrays(GL_TRIANGLES, 0, 3); glUseProgram(shaderProgram2); glBindVertexArray(VAOs[1]); glDrawArrays(GL_TRIANGLES, 0, 3); glfwSwapBuffers(window); glfwPollEvents(); &#125; glDeleteVertexArrays(2, VAOs); glDeleteBuffers(2, VBOs); glfwTerminate(); return 0;&#125;void processInput(GLFWwindow* window) &#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123; glfwSetWindowShouldClose(window, true); &#125;&#125;void framebuffer_size_callback(GLFWwindow* window, int width, int height) &#123; glViewport(0, 0, width, height);&#125;]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用不同的VAO和VBO创建两个对称三角形]]></title>
    <url>%2F2018%2F05%2F06%2Fopengl-base4%2F</url>
    <content type="text"><![CDATA[考察VAO和VBO数组的使用 123456789#ifndef _FRAGMENTSHADER_H_#define _FRAGMENTSHADER_H_const char * fragmentShaderSource ="#version 330 core\n"//out：声明输出变量"out vec4 FragColor;\n""void main()&#123;\n""FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n" //输出为固定颜色"&#125;\0"; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#ifndef _VERTEXSHADER_H_#define _VERTEXSHADER_H_const char* vertexShaderSource ="#version 330 core\n""layout (location = 0) in vec3 aPos;\n""void main()&#123;\n""gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n""&#125;\0";#endif // !_VERTEXSHADER_H_```C++//创建两个相同的三角形，但对他们的数据使用不同的VAO和VBO#include &lt;glad\glad.h&gt;#include &lt;GLFW\glfw3.h&gt;#include &lt;iostream&gt;#include "VertexShader.h"#include "FragmentShader.h"void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow* window);const unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;int main() &#123; glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "LearnOpenGL", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; "Failed to create GLFW window" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl; return -1; &#125; int vertexShader = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL); glCompileShader(vertexShader); int success; char infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILEATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL); glCompileShader(fragmentShader); glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; int shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::PORGRAM::LINKING_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; glDeleteShader(vertexShader); glDeleteShader(fragmentShader); float firstTriangle[] = &#123; -0.9f, -0.5f, 0.0f, -0.0f, -0.5f, 0.0f, -0.45f, 0.5f, 0.0f, &#125;; float secondTriangle[] = &#123; 0.0f, -0.5f, 0.0f, 0.9f, -0.5f, 0.0f, 0.45f, 0.5f, 0.0f &#125;; unsigned int VBOs[2], VAOs[2]; glGenVertexArrays(2, VAOs); glGenBuffers(2, VBOs); //没有解除绑定的操作，因为使用了不同的VAO，所以不需要 glBindVertexArray(VAOs[0]); glBindBuffer(GL_ARRAY_BUFFER, VBOs[0]); glBufferData(GL_ARRAY_BUFFER, sizeof(firstTriangle), firstTriangle, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glBindVertexArray(VAOs[1]); glBindBuffer(GL_ARRAY_BUFFER, VBOs[1]); glBufferData(GL_ARRAY_BUFFER, sizeof(secondTriangle), secondTriangle, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); while (!glfwWindowShouldClose(window)) &#123; processInput(window); glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(shaderProgram); glBindVertexArray(VAOs[0]); glDrawArrays(GL_TRIANGLES, 0, 3); glBindVertexArray(VAOs[1]); glDrawArrays(GL_TRIANGLES, 0, 3); glfwSwapBuffers(window); glfwPollEvents(); &#125; glDeleteVertexArrays(2, VAOs); glDeleteBuffers(2, VBOs); glfwTerminate(); return 0;&#125;void processInput(GLFWwindow* window) &#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123; glfwSetWindowShouldClose(window, true); &#125;&#125;void framebuffer_size_callback(GLFWwindow* window, int width, int height) &#123; glViewport(0, 0, width, height);&#125;]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[绘制两个对称且有一个顶点连接的三角形]]></title>
    <url>%2F2018%2F05%2F06%2Fopengl-base3%2F</url>
    <content type="text"><![CDATA[考察顶点着色器的使用 123456789#ifndef _FRAGMENTSHADER_H_#define _FRAGMENTSHADER_H_const char * fragmentShaderSource ="#version 330 core\n"//out：声明输出变量"out vec4 FragColor;\n""void main()&#123;\n""FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n" //输出为固定颜色"&#125;\0"; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#ifndef _VERTEXSHADER_H_#define _VERTEXSHADER_H_const char* vertexShaderSource ="#version 330 core\n""layout (location = 0) in vec3 aPos;\n""void main()&#123;\n""gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n""&#125;\0";#endif // !_VERTEXSHADER_H_```c++#include &lt;glad\glad.h&gt;#include &lt;GLFW\glfw3.h&gt;#include &lt;iostream&gt;#include "FragmentShader.h"#include "VertexShader.h"const unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow* window);int main() &#123; glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "LearnOpenGL", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; "Failed to create GLFW window" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl; return -1; &#125; int vertexShader = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL); glCompileShader(vertexShader); int success; char infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success); if(!success)&#123; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILEATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL); glCompileShader(fragmentShader); glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::FRAGMENT::COMPILEATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; int shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::PROGRAM::LINK_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; glDeleteShader(vertexShader); glDeleteShader(fragmentShader); float vertices[] = &#123; // first triangle -0.9f, -0.5f, 0.0f, // left -0.0f, -0.5f, 0.0f, // right -0.45f, 0.5f, 0.0f, // top // second triangle 0.0f, -0.5f, 0.0f, // left 0.9f, -0.5f, 0.0f, // right 0.45f, 0.5f, 0.0f // top &#125;; unsigned int VBO, VAO; glGenVertexArrays(1, &amp;VAO); glGenBuffers(1, &amp;VBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glBindBuffer(GL_ARRAY_BUFFER, 0); glBindVertexArray(0); while (!glfwWindowShouldClose(window)) &#123; processInput(window); glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES, 0, 6); glfwSwapBuffers(window); glfwPollEvents(); &#125; glDeleteVertexArrays(1, &amp;VBO); glDeleteBuffers(1, &amp;VBO); glfwTerminate(); return 0;&#125;void framebuffer_size_callback(GLFWwindow* window, int width, int height) &#123; glViewport(0, 0, width, height);&#125;void processInput(GLFWwindow* window) &#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123; glfwSetWindowShouldClose(window, true); &#125;&#125;]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[通过OpenGL绘制正方形]]></title>
    <url>%2F2018%2F05%2F06%2Fopengl-base2%2F</url>
    <content type="text"><![CDATA[主要通过使用索引数组传值（GL_ELEMENT_ARRAY_BUFFER）的方式，减少顶点输入 片段着色器FragmentShader.h 123456789#ifndef _FRAGMENTSHADER_H_#define _FRAGMENTSHADER_H_const char * fragmentShaderSource ="#version 330 core\n"//out：声明输出变量"out vec4 FragColor;\n""void main()&#123;\n""FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n" //输出为固定颜色"&#125;\0"; 顶点着色器VertexShader.h 123456789101112131415#ifndef _VERTEXSHADER_H_#define _VERTEXSHADER_H_const char* vertexShaderSource ="#version 330 core\n" //声明版本并使用核心模式//in：顶点着色器中声明所有的输入顶点属性，现阶段只关心位置数据，所以只需要设置一个顶点属性。//GLSL（着色器语言）有一个向量类型，包含1--4个float分量。//layout (location = 0)设定了输入变量的位置值，相当于一个索引，可以在代码中通过glVertexAttribPointer指定传入参数、通过glEnableVertexAttribArray启用数据，放入aPos中。"layout (location = 0) in vec3 aPos;\n""void main()&#123;\n"//为了设置顶点着色器输出，必须把位置数据赋值给预定义的gl_Position变量，而gl_Position本身是一个vec4类型，在main函数最后需要将三分量的值转为四分量的值"gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n""&#125;\0";#endif // !_VERTEXSHADER_H_ main函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161//绘制正方形#include &lt;glad\glad.h&gt;#include &lt;GLFW\glfw3.h&gt;#include "VertexShader.h"#include "FragmentShader.h"#include &lt;iostream&gt;/*OpenGL基于3维坐标系，OpenGL的大部分工作就是3D坐标系转为2D坐标系。该转化过程由OpenGL图形渲染管线完成。分为两步：一、3D坐标转2D坐标；二、2D坐标转实际有颜色的像素*/void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow* window);const unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;int main() &#123; glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "LearnOpenGL", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; "Failed to create GLFW window." &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl; return -1; &#125; //顶点着色器：是可编程着色器之一。现代OpenGL需要至少设置一个顶点和一个片段着色器。 unsigned int vertexShader; //vertexShader：用ID来引用着色器对象 vertexShader = glCreateShader(GL_VERTEX_SHADER); //创建一个着色器对象，GL_VERTEX_SHADER：顶点着色器 glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL); //参数1：将要编译的着色器；参数2：源码字符串数量；参数3：顶点着色器真正的源码；参数4：指定字符串长度的数组。 glCompileShader(vertexShader); //检查着色器编译时是否报错 int success; char infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR:SHADER::VERTEX::COMPOLEATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; //片段着色器：计算像素最后的颜色输出 unsigned int fragmentShader; fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL); glCompileShader(fragmentShader); glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::FRAGMENT::COMPLATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; //将着色器链接到一个用来渲染的着色器程序 //着色器程序对象：是多个着色器合并之后并最终链接完成的版本。如果想要使用着色器，必须链接为一个着色器程序对象，然后渲染对象时激活这个着色器程序。 unsigned int shaderProgram; shaderProgram = glCreateProgram(); //glCreateProgram：创建一个着色器程序，并返回ID引用 glAttachShader(shaderProgram, vertexShader); //附加着色器 glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); //链接着色器 //检测链接着色器程序是否失败 glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADERPROGRAM::COMPOLEATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; //着色器对象链接到程序对象之后，删除着色器对象。 glDeleteShader(vertexShader); glDeleteShader(fragmentShader); //定义一个正方形顶点数组，作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。其会在GPU上创建内存用于储存顶点数据。 //还需配置OpenGL如何解释该内存，指定其如何发送给显卡。顶点着色器会处理在内存中指定数量的顶点。 //绘制正方形时，使用索引缓冲对象（Element Buffer Object，EBO）用以节省内存。 float vertices[] = &#123; 0.5f, 0.5f, 0.0f, // 左上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角 &#125;; unsigned int indices[] = &#123; 0, 1, 3, 1, 2, 3 &#125;; unsigned int VBO; //顶点缓冲对象：OpenGL对象都有一个独一无二的ID glGenBuffers(1, &amp;VBO); //glGenBuffers： 生成一个VBO对象，VBO保存ID。 unsigned int VAO; glGenVertexArrays(1, &amp;VAO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); unsigned int EBO; glGenBuffers(1, &amp;EBO); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); //以顶点属性位置值作为参数，启用顶点属性，默认顶点属性是禁用的。 glEnableVertexAttribArray(0); //解绑VAO和VBO glBindBuffer(GL_ARRAY_BUFFER, 0); glBindVertexArray(0); glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); while (!glfwWindowShouldClose(window)) &#123; //检测输入 processInput(window); //渲染 glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); //得到一个程序对象，调用useProgram函数，激活这个程序对象。之后，着色器调用和渲染调用都将使用这个程序对象。 glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); glBindVertexArray(0); glfwSwapBuffers(window);//交换指定窗口双缓冲区的前后缓冲 glfwPollEvents();//该函数会调用相关的窗口和输入回调 &#125; glDeleteVertexArrays(1, &amp;VAO); glDeleteBuffers(1, &amp;VBO); glfwTerminate(); return 0;&#125;void processInput(GLFWwindow* window) &#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123; glfwSetWindowShouldClose(window, true); &#125;&#125;void framebuffer_size_callback(GLFWwindow* window, int width, int height) &#123; glViewport(0, 0, width, height);&#125;]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习网址]]></title>
    <url>%2F2018%2F04%2F16%2Fdailycollection1%2F</url>
    <content type="text"><![CDATA[OpenGL中文站：https://learnopengl-cn.github.io]]></content>
      <categories>
        <category>日常搜集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[通过OpenGL画三角形]]></title>
    <url>%2F2018%2F04%2F16%2Fopengl-base1%2F</url>
    <content type="text"><![CDATA[通过绘制三角形，介绍顶点着色器和片段着色器 片段着色器FragmentShader.h 123456789#ifndef _FRAGMENTSHADER_H_#define _FRAGMENTSHADER_H_const char * fragmentShaderSource ="#version 330 core\n"//out：声明输出变量"out vec4 FragColor;\n""void main()&#123;\n""FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n" //输出为固定颜色"&#125;\0"; 顶点着色器VertexShader.h 123456789101112131415#ifndef _VERTEXSHADER_H_#define _VERTEXSHADER_H_const char* vertexShaderSource ="#version 330 core\n" //声明版本并使用核心模式//in：顶点着色器中声明所有的输入顶点属性，现阶段只关心位置数据，所以只需要设置一个顶点属性。//GLSL（着色器语言）有一个向量类型，包含1--4个float分量。//layout (location = 0)设定了输入变量的位置值，相当于一个索引，可以在代码中通过glVertexAttribPointer指定传入参数、通过glEnableVertexAttribArray启用数据，放入aPos中。"layout (location = 0) in vec3 aPos;\n""void main()&#123;\n"//为了设置顶点着色器输出，必须把位置数据赋值给预定义的gl_Position变量，而gl_Position本身是一个vec4类型，在main函数最后需要将三分量的值转为四分量的值"gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n""&#125;\0";#endif // !_VERTEXSHADER_H_ main函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include &lt;glad\glad.h&gt;#include &lt;GLFW\glfw3.h&gt;#include "VertexShader.h"#include "FragmentShader.h"#include &lt;iostream&gt;/* OpenGL基于3维坐标系，OpenGL的大部分工作就是3D坐标系转为2D坐标系。该转化过程由OpenGL图形渲染管线完成。分为两步：一、3D坐标转2D坐标；二、2D坐标转实际有颜色的像素*/void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow* window);const unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;int main() &#123; glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "LearnOpenGL", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; "Failed to create GLFW window." &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl; return -1; &#125; //顶点着色器：是可编程着色器之一。现代OpenGL需要至少设置一个顶点和一个片段着色器。 unsigned int vertexShader; //vertexShader：用ID来引用着色器对象 vertexShader = glCreateShader(GL_VERTEX_SHADER); //创建一个着色器对象，GL_VERTEX_SHADER：顶点着色器 glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL); //参数1：将要编译的着色器；参数2：源码字符串数量；参数3：顶点着色器真正的源码；参数4：指定字符串长度的数组。 glCompileShader(vertexShader); //检查着色器编译时是否报错 int success; char infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR:SHADER::VERTEX::COMPOLEATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; //片段着色器：计算像素最后的颜色输出 unsigned int fragmentShader; fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); // GL_FRAGMENT_SHADER：片段着色器 glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL); glCompileShader(fragmentShader); glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::FRAGMENT::COMPLATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; //将着色器链接到一个用来渲染的着色器程序 //着色器程序对象：是多个着色器合并之后并最终链接完成的版本。如果想要使用着色器，必须链接为一个着色器程序对象，然后渲染对象时激活这个着色器程序。 unsigned int shaderProgram; shaderProgram = glCreateProgram(); //glCreateProgram：创建一个着色器程序，并返回ID引用 glAttachShader(shaderProgram, vertexShader); //附加着色器 glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); //链接着色器 //检测链接着色器程序是否失败 glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADERPROGRAM::COMPOLEATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; //着色器对象链接到程序对象之后，删除着色器对象。 glDeleteShader(vertexShader); glDeleteShader(fragmentShader); //定义一个三角形顶点数组，作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。其会在GPU上创建内存用于储存顶点数据。 //还需配置OpenGL如何解释该内存，指定其如何发送给显卡。顶点着色器会处理在内存中指定数量的顶点。 float vertices[] = &#123; -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f &#125;; //通过顶点缓冲对象（Vertex Buffer Objects，VBO）管理这个内存，其会在GPU内存（显存）中储存大量顶点。 //优势在于，可一次性发送大批数据至显卡。因为CPU把数据发送到显卡相对较慢，所以需要尽量一次发送尽可能多的数据。 unsigned int VBO; //顶点缓冲对象：OpenGL对象都有一个独一无二的ID glGenBuffers(1, &amp;VBO); //glGenBuffers： 生成一个VBO对象，VBO保存ID。 //顶点数组对象（Vertex Array Object）：可以像顶点缓冲对象被绑定，任何随后的顶点属性都会储存在VAO中。 //绑定后，当配置顶点属性指针时，只需要将那些调用执行一次，之后在绘制物体时，只需要绑定相应的VAO即可。 //顶点数据对象的储存内容： 1、glEnableVertexAttribArray和glDisableVertexAttribArray的调用。 // 2、通过glVertexAttribPointer设置的顶点属性配置。 // 3、通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。 unsigned int VAO; glGenVertexArrays(1, &amp;VAO); glBindVertexArray(VAO); //GL_ARRAY_BUFFER：顶点缓冲对象类型，是缓冲对象类型中的一个。OpenGL允许同时绑定多个缓冲，只要是不同的缓冲类型。 //glBindBuffer：绑定函数，将新创建的缓冲绑定到GL_ARRAY_BUFFER目标上。 //调用完成后，接下来使用的任何缓冲调用都会用来配置当前绑定的缓冲。 glBindBuffer(GL_ARRAY_BUFFER, VBO); //glBufferData：把之前定义的顶点数据复制到缓冲的内存中 //参数：1、目标缓存的类型，顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上； // 2、指定传输数据的大小（字节为单位）； // 3、实际发送的数据； // 4、指定如何管理数据（GL_STATIC_DRAW(数据不会或几乎不会改变)、GL_DUNAMIC_DRAW(数据会被改变很多)、GL_STREAM_DRAW（数据每次绘制都会改变）），该选项会决定显卡是否将数据放入高速写入的内存部分。 //调用完成后，顶点数据存储在显卡的内存中，用VBO顶点缓冲对象管理。 glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); //链接顶点属性：顶点着色器可以用任何顶点属性为形式的输入。我们必须手动指定输入数据部分对应的顶点属性，在渲染前指定OpenGL如何解释顶点数据。 //glVertexAttribPointer: 参数1：指定配置的顶点属性，（layout(location = 0)：顶点着色器中定义的顶点属性的位置值） // 参数2：顶点属性的大小。顶点属性是vec3，所以为3 // 参数3：指定数据类型， // 参数4：是否希望数据被标准化，GL_TRUE时，数据会被映射到0（有符号型signed数据为-1）至1之间。 // 参数5：步长，连续顶点属性组之间的间隔。当数组是紧密排列时，可用0来让OpenGL自行决定步长。 // 参数6：类型必须为void*，表示位置数据在缓冲中起始位置的偏移量。由于位置数据在开头，所以无偏差。 //每个顶点属性从一个VBO管理的内存中获取数据，VBO是在调用glVetexAttribPointer之前绑定到GL_ARRAY_BUFFER的VBO指定的。 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); //以顶点属性位置值作为参数，启用顶点属性，默认顶点属性是禁用的。 glEnableVertexAttribArray(0); //解绑VAO和VBO glBindBuffer(GL_ARRAY_BUFFER, 0); glBindVertexArray(0); while (!glfwWindowShouldClose(window)) &#123; //检测输入 processInput(window); //渲染 glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); //调用useProgram函数，激活程序对象。之后，着色器调用和渲染调用都将使用这个程序对象。 glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES, 0, 3); glfwSwapBuffers(window);//交换指定窗口双缓冲区的前后缓冲 glfwPollEvents();//该函数会调用相关的窗口和输入回调 &#125; glDeleteVertexArrays(1, &amp;VAO); glDeleteBuffers(1, &amp;VBO); glfwTerminate(); return 0;&#125;void processInput(GLFWwindow* window) &#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123; glfwSetWindowShouldClose(window, true); &#125;&#125;void framebuffer_size_callback(GLFWwindow* window, int width, int height) &#123; glViewport(0, 0, width, height);&#125;]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
</search>
